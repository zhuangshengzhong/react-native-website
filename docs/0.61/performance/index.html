<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>性能 · React Native 中文网</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="##### 本文档贡献者：[sunnylqm](https://github.com/search?q=sunnylqm%40qq.com+in%3Aemail&amp;type=Users)(99.27%), [280215110](https://github.com/search?q=280215110%40qq.com+in%3Aemail&amp;type=Users)(0.73%)"/><meta name="docsearch:version" content="0.61"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="性能 · React Native 中文网"/><meta property="og:type" content="website"/><meta property="og:url" content="undefined/"/><meta property="og:description" content="##### 本文档贡献者：[sunnylqm](https://github.com/search?q=sunnylqm%40qq.com+in%3Aemail&amp;type=Users)(99.27%), [280215110](https://github.com/search?q=280215110%40qq.com+in%3Aemail&amp;type=Users)(0.73%)"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-dark.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-63485149-4', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/focus-visible@5.0.2/dist/focus-visible.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/codeblocks.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/tabs.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/doccode0814.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/snack.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/scrollSpy.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/css/prism.css"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/css/main.css"/><script src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/img/header_logo.svg" alt="React Native 中文网"/><h2 class="headerTitleWithLogo">React Native 中文网</h2></a><a href="/versions"><h3>0.61</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/0.61/getting-started" target="_self">文档</a></li><li class="siteNavGroupActive"><a href="/docs/0.61/components-and-apis" target="_self">组件</a></li><li class=""><a href="/docs/0.61/accessibilityinfo" target="_self">API</a></li><li class=""><a href="//github.com/reactnativecn/react-native-website/issues" target="_blank">讨论</a></li><li class=""><a href="//pushy.reactnative.cn" target="_blank">热更新</a></li><li class=""><a href="/about" target="_self">关于</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/react-native" target="_self">GitHub</a></li><li class=""><a href="//zh-hans.reactjs.org/" target="_blank">React</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>进阶指南</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">入门基础<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/getting-started">搭建开发环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/intro-react-native-components">核心组件与原生组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/intro-react">React基础</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/tutorial">示例教程：Hello World</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/props">Props（属性）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/state">State（状态）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/handling-text-input">处理文本输入</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/handling-touches">处理触摸事件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/using-a-scrollview">使用滚动视图</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/using-a-listview">使用长列表</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/network">网络</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/sample-application-movies">示例教程：电影列表</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/more-resources">其他参考资源</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">设计<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/style">样式</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/height-and-width">高度与宽度</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/flexbox">使用Flexbox布局</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶指南<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/components-and-apis">组件和API</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/fast-refresh">快速自动刷新 Fast Refresh</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/platform-specific-code">特定平台代码</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/navigation">使用导航器跳转页面</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/images">图片</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/animations">动画</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/accessibility">无障碍功能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/improvingux">改进用户体验</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/optimizing-flatlist-configuration">列表配置优化</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/timers">定时器</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/debugging">调试</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/docs/0.61/performance">性能</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/gesture-responder-system">手势响应系统</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/javascript-environment">JavaScript环境</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/typescript">使用TypeScript</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/direct-manipulation">直接操作</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/colors">颜色</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/integration-with-existing-apps">集成到现有原生应用</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/building-for-apple-tv">为电视和机顶盒制作应用</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/running-on-device">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/upgrading">更新</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/native-modules-setup">原生模块配置</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/out-of-tree-platforms">多平台支持</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/building-from-source">从源代码编译React Native</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/publishing-forks">发布自己定制的ReactNative包</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/testing">Testing your Changes</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(iOS)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/native-modules-ios">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/native-components-ios">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/linking-libraries-ios">链接原生库</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/running-on-simulator-ios">在iOS模拟器上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/communication-ios">和原生端通信</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/app-extensions">iOS应用扩展</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(Android)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/0.61/native-modules-android">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/native-components-android">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/headless-js-android">Headless JS（后台任务）</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/signed-apk-android">打包APK</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/removing-default-permissions">移除不需要的权限</a></li><li class="navListItem"><a class="navItem" href="/docs/0.61/hermes">Using Hermes</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="//github.com/reactnativecn/react-native-website/blob/production/cndocs/performance.md" target="_blank" rel="noreferrer noopener">帮助改进此文档</a><h1 id="__docusaurus" class="postHeaderTitle">性能</h1></header><article><div><span><h5><a class="anchor" aria-hidden="true" id="本文档贡献者：sunnylqmhttpsgithubcomsearchqsunnylqm40qqcomin3aemailtypeusers9927-280215110httpsgithubcomsearchq28021511040qqcomin3aemailtypeusers073"></a><a href="#本文档贡献者：sunnylqmhttpsgithubcomsearchqsunnylqm40qqcomin3aemailtypeusers9927-280215110httpsgithubcomsearchq28021511040qqcomin3aemailtypeusers073" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>本文档贡献者：<a href="https://github.com/search?q=sunnylqm%40qq.com+in%3Aemail&amp;type=Users">sunnylqm</a>(99.27%), <a href="https://github.com/search?q=280215110%40qq.com+in%3Aemail&amp;type=Users">280215110</a>(0.73%)</h5>
<p>使用 React Native 替代基于 WebView 的框架来开发 App 的一个强有力的理由，就是为了使 App 可以达到每秒 60 帧（足够流畅），并且能有类似原生 App 的外观和手感。因此我们也尽可能地优化 React Native 去实现这一目标，使开发者能集中精力处理 App 的业务逻辑，而不用费心考虑性能。但是，总还是有一些地方有所欠缺，以及在某些场合 React Native 还不能够替你决定如何进行优化（用原生代码写也无法避免），因此人工的干预依然是必要的。</p>
<p>本文的目的是教给你一些基本的知识，来帮你排查性能方面的问题，以及探讨这些问题产生的原因和推荐的解决方法。</p>
<h2><a class="anchor" aria-hidden="true" id="关于帧你所需要知道的"></a><a href="#关于帧你所需要知道的" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于“帧”你所需要知道的</h2>
<p>老一辈人常常把电影称为“移动的画”，是因为视频中逼真的动态效果其实是一种幻觉，这种幻觉是由一组静态的图片以一个稳定的速度快速变化所产生的。我们把这组图片中的每一张图片叫做一帧，而每秒钟显示的帧数直接的影响了视频（或者说用户界面）的流畅度和真实感。iOS 设备提供了每秒 60 的帧率，这就留给了开发者和 UI 系统大约 16.67ms 来完成生成一张静态图片（帧）所需要的所有工作。如果在这分派的 16.67ms 之内没有能够完成这些工作，就会引发‘丢帧’的后果，使界面表现的不够流畅。</p>
<p>下面要讲的事情可能更为复杂：请先调出你应用的开发菜单，打开<code>Show FPS Monitor</code>. 你会注意到有两个不同的帧率.</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/PerfUtil.png" alt=""></p>
<h3><a class="anchor" aria-hidden="true" id="js-帧率javascript-线程"></a><a href="#js-帧率javascript-线程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JS 帧率(JavaScript 线程)</h3>
<p>对大多数 React Native 应用来说，业务逻辑是运行在 JavaScript 线程上的。这是 React 应用所在的线程，也是发生 API 调用，以及处理触摸事件等操作的线程。更新数据到原生支持的视图是批量进行的，并且在事件循环每进行一次的时候被发送到原生端，这一步通常会在一帧时间结束之前处理完（如果一切顺利的话）。如果 JavaScript 线程有一帧没有及时响应，就被认为发生了一次丢帧。 例如，你在一个复杂应用的根组件上调用了<code>this.setState</code>，从而导致一次开销很大的子组件树的重绘，可想而知，这可能会花费 200ms 也就是整整 12 帧的丢失。此时，任何由 JavaScript 控制的动画都会卡住。只要卡顿超过 100ms，用户就会明显的感觉到。</p>
<p>这种情况经常发生在老的<code>Navigator</code>导航器的切换过程中：当你 push 一个新的路由时，JavaScript 需要绘制新场景所需的所有组件，以发送正确的命令给原生端去创建视图。由于切换是由 JavaScript 线程所控制，因此经常会占用若干帧的时间，引起一些卡顿。有的时候，组件会在<code>componentDidMount</code>函数中做一些额外的事情，这甚至可能会导致页面切换过程中多达一秒的卡顿。</p>
<p>另一个例子是老的触摸事件的响应：如果你正在 JavaScript 线程处理一个跨越多个帧的工作，你可能会注意到<code>TouchableOpacity</code>的响应被延迟了。这是因为 JavaScript 线程太忙了，不能够处理主线程发送过来的原始触摸事件，结果<code>TouchableOpacity</code>就不能及时响应这些事件并命令主线程的页面去调整透明度了。</p>
<h3><a class="anchor" aria-hidden="true" id="ui-帧率主线程"></a><a href="#ui-帧率主线程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>UI 帧率(主线程)</h3>
<p>很多人会注意到，<code>NavigatorIOS</code>的性能要比老的纯 JS 实现的<code>Navigator</code>好的多。原因就是它的切换动画是完全在主线程上执行的，因此不会被 JavaScript 线程上的掉帧所影响。</p>
<p>同样，当 JavaScript 线程卡住的时候，你仍然可以欢快的上下滚动<code>ScrollView</code>，因为<code>ScrollView</code>运行在主线程之上（尽管滚动事件会被分发到 JS 线程，但是接收这些事件对于滚动这个动作来说并不必要）。</p>
<h2><a class="anchor" aria-hidden="true" id="性能问题的常见原因"></a><a href="#性能问题的常见原因" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>性能问题的常见原因</h2>
<h3><a class="anchor" aria-hidden="true" id="开发模式-devtrue"></a><a href="#开发模式-devtrue" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>开发模式 (<code>dev=true</code>)</h3>
<p>JavaScript 线程的性能在开发模式下是很糟糕的。这是不可避免的，因为有许多工作需要在运行的时候去做，譬如使你获得良好的警告和错误信息，又比如验证属性类型（propTypes）以及产生各种其他的警告。请务必注意在<a href="/docs/0.61/running-on-device#发布应用">release 模式</a>下去测试性能。</p>
<h3><a class="anchor" aria-hidden="true" id="consolelog-语句"></a><a href="#consolelog-语句" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>console.log 语句</h3>
<p>在运行打好了离线包的应用时，控制台大量打印语句可能会拖累 JavaScript 线程。注意有些第三方调试库也可能包含控制台打印语句，比如<a href="https://github.com/evgenyrodionov/redux-logger">redux-logger</a>，所以在发布应用前请务必仔细检查，确保全部移除。</p>
<blockquote>
<p>有个<a href="https://babeljs.io/docs/plugins/transform-remove-console/">babel 插件</a>可以帮你移除所有的<code>console.*</code>调用。首先需要使用<code>yarn add --dev babel-plugin-transform-remove-console</code>来安装，然后在项目根目录下编辑（或者是新建）一个名为·.babelrc`的文件，在其中加入：</p>
</blockquote>
<pre><code class="hljs css language-json"><span class="token punctuation">{</span>
  <span class="token property">"env"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token property">"production"</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"transform-remove-console"</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>这样在打包发布时，所有的控制台语句就会被自动移除，而在调试时它们仍然会被正常调用。</p>
<h3><a class="anchor" aria-hidden="true" id="listview-首次渲染缓慢或者由于列表很大导致滑动很慢"></a><a href="#listview-首次渲染缓慢或者由于列表很大导致滑动很慢" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>ListView</code> 首次渲染缓慢或者由于列表很大导致滑动很慢</h3>
<p>用新的<a href="/docs/0.61/flatlist"><code>FlatList</code></a>或者<a href="/docs/0.61/sectionlist"><code>SectionList</code></a>组件替代。除了简化了API，这些新的列表组件在性能方面都有了极大的提升, 其中最主要的一个是无论列表有多少行，它的内存使用都是常数级的。</p>
<p>如果你的<a href="/docs/0.61/flatlist"><code>FlatList</code></a>渲染得很慢, 请确保你使用了<a href="/docs/0.61/flatlist#getitemlayout"><code>getItemLayout</code></a>，它通过跳过对items的处理来优化你的渲染速度。</p>
<h3><a class="anchor" aria-hidden="true" id="在重绘一个几乎没有什么变化的页面时，js-帧率严重降低"></a><a href="#在重绘一个几乎没有什么变化的页面时，js-帧率严重降低" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在重绘一个几乎没有什么变化的页面时，JS 帧率严重降低</h3>
<p>你可以实现<code>shouldComponentUpdate</code>函数来指明在什么样的确切条件下，你希望这个组件得到重绘。如果你编写的是纯粹的组件（界面完全由 props 和 state 所决定），你可以利用<code>PureComponent</code>来为你做这个工作。再强调一次，不可变的数据结构（immutable，即对于引用类型数据，不修改原值，而是复制后修改并返回新值）在提速方面非常有用 —— 当你不得不对一个长列表对象做一个深度的比较，它会使重绘你的整个组件更加快速，而且代码量更少。</p>
<h3><a class="anchor" aria-hidden="true" id="在屏幕上移动视图（滚动，切换，旋转）时，ui-线程掉帧"></a><a href="#在屏幕上移动视图（滚动，切换，旋转）时，ui-线程掉帧" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在屏幕上移动视图（滚动，切换，旋转）时，UI 线程掉帧</h3>
<p>当具有透明背景的文本位于一张图片上时，或者在每帧重绘视图时需要用到透明合成的任何其他情况下，这种现象尤为明显。设置<code>shouldRasterizeIOS</code>或者<code>renderToHardwareTextureAndroid</code>属性可以显著改善这一现象。
注意不要过度使用该特性，否则你的内存使用量将会飞涨。在使用时，要评估你的性能和内存使用情况。如果你没有需要移动这个视图的需求，请关闭这一属性。</p>
<h3><a class="anchor" aria-hidden="true" id="使用动画改变图片的尺寸时，ui-线程掉帧"></a><a href="#使用动画改变图片的尺寸时，ui-线程掉帧" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用动画改变图片的尺寸时，UI 线程掉帧</h3>
<p>在 iOS 上，每次调整 Image 组件的宽度或者高度，都需要重新裁剪和缩放原始图片。这个操作开销会非常大，尤其是大的图片。比起直接修改尺寸，更好的方案是使用<code>transform: [{scale}]</code>的样式属性来改变尺寸。比如当你点击一个图片，要将它放大到全屏的时候，就可以使用这个属性。</p>
<h3><a class="anchor" aria-hidden="true" id="touchable-系列组件不能很好的响应"></a><a href="#touchable-系列组件不能很好的响应" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Touchable 系列组件不能很好的响应</h3>
<p>有些时候，如果我们有一项操作与点击事件所带来的透明度改变或者高亮效果发生在同一帧中，那么有可能在<code>onPress</code>函数结束之前我们都看不到这些效果。比如在<code>onPress</code>执行了一个<code>setState</code>的操作，这个操作需要大量计算工作并且导致了掉帧。对此的一个解决方案是将<code>onPress</code>处理函数中的操作封装到<code>requestAnimationFrame</code>中：</p>
<pre><code class="hljs css language-jsx"><span class="token function">handleOnPress</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 谨记在使用requestAnimationFrame、setTimeout以及setInterval时</span>
  <span class="token comment">// 要使用TimerMixin（其作用是在组件unmount时，清除所有定时器）</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">doExpensiveAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="分析"></a><a href="#分析" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分析</h2>
<p>你可以利用内置的分析器来同时获取 JavaScript 线程和主线程中代码执行情况的详细信息。</p>
<p>对于 iOS 来说，Instruments 是一个宝贵的工具库，Android 的话可以使用 systrace，具体可以参考下面的<code>使用 systrace 调试 Android UI 性能</code>。</p>
<p>But first, <a href="/docs/0.61/performance#running-in-development-mode-dev-true"><strong>make sure that Development Mode is OFF!</strong></a> You should see <code>__DEV__ === false, development-level warning are OFF, performance optimizations are ON</code> in your application logs.</p>
<p>Another way to profile JavaScript is to use the Chrome profiler while debugging. This won't give you accurate results as the code is running in Chrome but will give you a general idea of where bottlenecks might be. Run the profiler under Chrome's <code>Performance</code> tab. A flame graph will appear under <code>User Timing</code>. To view more details in tabular format, click at the <code>Bottom Up</code> tab below and then select <code>DedicatedWorker Thread</code> at the top left menu.</p>
<h3><a class="anchor" aria-hidden="true" id="使用-systrace-调试-android-ui-性能"></a><a href="#使用-systrace-调试-android-ui-性能" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>使用 systrace 调试 Android UI 性能</h3>
<p>Android supports 10k+ different phones and is generalized to support software rendering: the framework architecture and need to generalize across many hardware targets unfortunately means you get less for free relative to iOS. But sometimes, there are things you can improve -- and many times it's not native code's fault at all!</p>
<p>The first step for debugging this jank is to answer the fundamental question of where your time is being spent during each 16ms frame. For that, we'll be using a standard Android profiling tool called <code>systrace</code>.</p>
<p><code>systrace</code> is a standard Android marker-based profiling tool (and is installed when you install the Android platform-tools package). Profiled code blocks are surrounded by start/end markers which are then visualized in a colorful chart format. Both the Android SDK and React Native framework provide standard markers that you can visualize.</p>
<h4><a class="anchor" aria-hidden="true" id="1-collecting-a-trace"></a><a href="#1-collecting-a-trace" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1. Collecting a trace</h4>
<p>First, connect a device that exhibits the stuttering you want to investigate to your computer via USB and get it to the point right before the navigation/animation you want to profile. Run <code>systrace</code> as follows:</p>
<pre><code class="hljs">$ <span class="hljs-symbol">&lt;path_to_android_sdk&gt;</span>/platform-tools/systrace/systrace.<span class="hljs-keyword">py</span> --time=<span class="hljs-number">10</span> -<span class="hljs-keyword">o</span> trace.html sched gfx <span class="hljs-keyword">view</span> -<span class="hljs-keyword">a</span> <span class="hljs-symbol">&lt;your_package_name&gt;</span>
</code></pre>
<p>A quick breakdown of this command:</p>
<ul>
<li><code>time</code> is the length of time the trace will be collected in seconds</li>
<li><code>sched</code>, <code>gfx</code>, and <code>view</code> are the android SDK tags (collections of markers) we care about: <code>sched</code> gives you information about what's running on each core of your phone, <code>gfx</code> gives you graphics info such as frame boundaries, and <code>view</code> gives you information about measure, layout, and draw passes</li>
<li><code>-a &lt;your_package_name&gt;</code> enables app-specific markers, specifically the ones built into the React Native framework. <code>your_package_name</code> can be found in the <code>AndroidManifest.xml</code> of your app and looks like <code>com.example.app</code></li>
</ul>
<p>Once the trace starts collecting, perform the animation or interaction you care about. At the end of the trace, systrace will give you a link to the trace which you can open in your browser.</p>
<h4><a class="anchor" aria-hidden="true" id="2-reading-the-trace"></a><a href="#2-reading-the-trace" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2. Reading the trace</h4>
<p>After opening the trace in your browser (preferably Chrome), you should see something like this:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceExample.png" alt="Example"></p>
<blockquote>
<p><strong>HINT</strong>: Use the WASD keys to strafe and zoom</p>
</blockquote>
<p>If your trace .html file isn't opening correctly, check your browser console for the following:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/ObjectObserveError.png" alt="ObjectObserveError"></p>
<p>Since <code>Object.observe</code> was deprecated in recent browsers, you may have to open the file from the Google Chrome Tracing tool. You can do so by:</p>
<ul>
<li>Opening tab in chrome <a href="chrome://tracing">chrome://tracing</a></li>
<li>Selecting load</li>
<li>Selecting the html file generated from the previous command.</li>
</ul>
<blockquote>
<p><strong>Enable VSync highlighting</strong></p>
<p>Check this checkbox at the top right of the screen to highlight the 16ms frame boundaries:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceHighlightVSync.png" alt="Enable VSync Highlighting"></p>
<p>You should see zebra stripes as in the screenshot above. If you don't, try profiling on a different device: Samsung has been known to have issues displaying vsyncs while the Nexus series is generally pretty reliable.</p>
</blockquote>
<h4><a class="anchor" aria-hidden="true" id="3-find-your-process"></a><a href="#3-find-your-process" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>3. Find your process</h4>
<p>Scroll until you see (part of) the name of your package. In this case, I was profiling <code>com.facebook.adsmanager</code>, which shows up as <code>book.adsmanager</code> because of silly thread name limits in the kernel.</p>
<p>On the left side, you'll see a set of threads which correspond to the timeline rows on the right. There are a few threads we care about for our purposes: the UI thread (which has your package name or the name UI Thread), <code>mqt_js</code>, and <code>mqt_native_modules</code>. If you're running on Android 5+, we also care about the Render Thread.</p>
<ul>
<li><p><strong>UI Thread.</strong> This is where standard android measure/layout/draw happens. The thread name on the right will be your package name (in my case book.adsmanager) or UI Thread. The events that you see on this thread should look something like this and have to do with <code>Choreographer</code>, <code>traversals</code>, and <code>DispatchUI</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceUIThreadExample.png" alt="UI Thread Example"></p></li>
<li><p><strong>JS Thread.</strong> This is where JavaScript is executed. The thread name will be either <code>mqt_js</code> or <code>&lt;...&gt;</code> depending on how cooperative the kernel on your device is being. To identify it if it doesn't have a name, look for things like <code>JSCall</code>, <code>Bridge.executeJSCall</code>, etc:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceJSThreadExample.png" alt="JS Thread Example"></p></li>
<li><p><strong>Native Modules Thread.</strong> This is where native module calls (e.g. the <code>UIManager</code>) are executed. The thread name will be either <code>mqt_native_modules</code> or <code>&lt;...&gt;</code>. To identify it in the latter case, look for things like <code>NativeCall</code>, <code>callJavaModuleMethod</code>, and <code>onBatchComplete</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceNativeModulesThreadExample.png" alt="Native Modules Thread Example"></p></li>
<li><p><strong>Bonus: Render Thread.</strong> If you're using Android L (5.0) and up, you will also have a render thread in your application. This thread generates the actual OpenGL commands used to draw your UI. The thread name will be either <code>RenderThread</code> or <code>&lt;...&gt;</code>. To identify it in the latter case, look for things like <code>DrawFrame</code> and <code>queueBuffer</code>:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceRenderThreadExample.png" alt="Render Thread Example"></p></li>
</ul>
<h4><a class="anchor" aria-hidden="true" id="identifying-a-culprit"></a><a href="#identifying-a-culprit" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Identifying a culprit</h4>
<p>A smooth animation should look something like the following:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceWellBehaved.png" alt="Smooth Animation"></p>
<p>Each change in color is a frame -- remember that in order to display a frame, all our UI work needs to be done by the end of that 16ms period. Notice that no thread is working close to the frame boundary. An application rendering like this is rendering at 60 FPS.</p>
<p>If you noticed chop, however, you might see something like this:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceBadJS.png" alt="Choppy Animation from JS"></p>
<p>Notice that the JS thread is executing basically all the time, and across frame boundaries! This app is not rendering at 60 FPS. In this case, <strong>the problem lies in JS</strong>.</p>
<p>You might also see something like this:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceBadUI.png" alt="Choppy Animation from UI"></p>
<p>In this case, the UI and render threads are the ones that have work crossing frame boundaries. The UI that we're trying to render on each frame is requiring too much work to be done. In this case, <strong>the problem lies in the native views being rendered</strong>.</p>
<p>At this point, you'll have some very helpful information to inform your next steps.</p>
<h4><a class="anchor" aria-hidden="true" id="resolving-javascript-issues"></a><a href="#resolving-javascript-issues" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolving JavaScript issues</h4>
<p>If you identified a JS problem, look for clues in the specific JS that you're executing. In the scenario above, we see <code>RCTEventEmitter</code> being called multiple times per frame. Here's a zoom-in of the JS thread from the trace above:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceBadJS2.png" alt="Too much JS"></p>
<p>This doesn't seem right. Why is it being called so often? Are they actually different events? The answers to these questions will probably depend on your product code. And many times, you'll want to look into <a href="https://facebook.github.io/react/component-specs.md#updating-shouldcomponentupdate">shouldComponentUpdate</a>.</p>
<h4><a class="anchor" aria-hidden="true" id="resolving-native-ui-issues"></a><a href="#resolving-native-ui-issues" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Resolving native UI Issues</h4>
<p>If you identified a native UI problem, there are usually two scenarios:</p>
<ol>
<li>the UI you're trying to draw each frame involves too much work on the GPU, or</li>
<li>You're constructing new UI during the animation/interaction (e.g. loading in new content during a scroll).</li>
</ol>
<h5><a class="anchor" aria-hidden="true" id="too-much-gpu-work"></a><a href="#too-much-gpu-work" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Too much GPU work</h5>
<p>In the first scenario, you'll see a trace that has the UI thread and/or Render Thread looking like this:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceBadUI.png" alt="Overloaded GPU"></p>
<p>Notice the long amount of time spent in <code>DrawFrame</code> that crosses frame boundaries. This is time spent waiting for the GPU to drain its command buffer from the previous frame.</p>
<p>To mitigate this, you should:</p>
<ul>
<li>investigate using <code>renderToHardwareTextureAndroid</code> for complex, static content that is being animated/transformed (e.g. the <code>Navigator</code> slide/alpha animations)</li>
<li>make sure that you are <strong>not</strong> using <code>needsOffscreenAlphaCompositing</code>, which is disabled by default, as it greatly increases the per-frame load on the GPU in most cases.</li>
</ul>
<p>If these don't help and you want to dig deeper into what the GPU is actually doing, you can check out <a href="http://developer.android.com/tools/help/gltracer.html">Tracer for OpenGL ES</a>.</p>
<h5><a class="anchor" aria-hidden="true" id="creating-new-views-on-the-ui-thread"></a><a href="#creating-new-views-on-the-ui-thread" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Creating new views on the UI thread</h5>
<p>In the second scenario, you'll see something more like this:</p>
<p><img src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/docs/assets/SystraceBadCreateUI.png" alt="Creating Views"></p>
<p>Notice that first the JS thread thinks for a bit, then you see some work done on the native modules thread, followed by an expensive traversal on the UI thread.</p>
<p>There isn't an easy way to mitigate this unless you're able to postpone creating new UI until after the interaction, or you are able to simplify the UI you're creating. The react native team is working on an infrastructure level solution for this that will allow new UI to be created and configured off the main thread, allowing the interaction to continue smoothly.</p>
<h2><a class="anchor" aria-hidden="true" id="拆包ram-bundles和内联引用"></a><a href="#拆包ram-bundles和内联引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拆包(RAM bundles)和内联引用</h2>
<p>如果你有一个较为庞大的应用程序，你可能要考虑使用<code>RAM</code>(Random Access Modules，随机存取模块）格式的 bundle 和内联引用。这对于具有大量页面的应用程序是非常有用的，这些页面在应用程序的典型使用过程中可能不会被打开。通常对于启动后一段时间内不需要大量代码的应用程序来说是非常有用的。例如应用程序包含复杂的配置文件屏幕或较少使用的功能，但大多数会话只涉及访问应用程序的主屏幕更新。我们可以通过使用<code>RAM</code>格式来优化<code>bundle</code>的加载，并且内联引用这些功能和页面（当它们被实际使用时）。</p>
<h3><a class="anchor" aria-hidden="true" id="加载-javascript"></a><a href="#加载-javascript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>加载 JavaScript</h3>
<p>在 react-native 执行 JS 代码之前，必须将代码加载到内存中并进行解析。如果你加载了一个 50MB 的 bundle，那么所有的 50mb 都必须被加载和解析才能被执行。RAM 格式的 bundle 则对此进行了优化，即启动时只加载 50MB 中实际需要的部分，之后再逐渐按需加载更多的包。</p>
<h3><a class="anchor" aria-hidden="true" id="内联引用"></a><a href="#内联引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内联引用</h3>
<p>内联引用(require 代替 import)可以延迟模块或文件的加载，直到实际需要该文件。一个基本的例子看起来像这样：</p>
<h4><a class="anchor" aria-hidden="true" id="优化前"></a><a href="#优化前" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化前</h4>
<pre><code class="hljs"><span class="hljs-keyword">import</span> <span class="hljs-type">React</span>, { <span class="hljs-type">Component</span> } from <span class="hljs-symbol">'reac</span>t';
<span class="hljs-keyword">import</span> { <span class="hljs-type">Text</span> } from <span class="hljs-symbol">'react</span>-native';
<span class="hljs-comment">// ... import some very expensive modules</span>

<span class="hljs-comment">// You may want to log at the file level to verify when this is happening</span>
console.log(<span class="hljs-symbol">'VeryExpensive</span> component loaded');

export <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VeryExpensive</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  <span class="hljs-comment">// lots and lots of code</span>
  render() {
    <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">Text</span>&gt;<span class="hljs-type">Very</span> <span class="hljs-type">Expensive</span> <span class="hljs-type">Component</span>&lt;/<span class="hljs-type">Text</span>&gt;;
  }
}
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="优化后"></a><a href="#优化后" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>优化后</h4>
<pre><code class="hljs"><span class="hljs-keyword">import</span> React, { Component } <span class="hljs-keyword">from</span> <span class="hljs-string">'react'</span>;
<span class="hljs-keyword">import</span> { TouchableOpacity, View, Text } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;

<span class="hljs-keyword">let</span> VeryExpensive = <span class="hljs-literal">null</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Optimized</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>{
  state = { <span class="hljs-attr">needsExpensive</span>: <span class="hljs-literal">false</span> };

  didPress = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-keyword">if</span> (VeryExpensive == <span class="hljs-literal">null</span>) {
      VeryExpensive = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./VeryExpensive'</span>).default;
    }

    <span class="hljs-keyword">this</span>.setState(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> ({
      <span class="hljs-attr">needsExpensive</span>: <span class="hljs-literal">true</span>,
    }));
  };

  render() {
    <span class="hljs-keyword">return</span> (
      <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">View</span> <span class="hljs-attr">style</span>=<span class="hljs-string">{{</span> <span class="hljs-attr">marginTop:</span> <span class="hljs-attr">20</span> }}&gt;</span>
        <span class="hljs-tag">&lt;<span class="hljs-name">TouchableOpacity</span> <span class="hljs-attr">onPress</span>=<span class="hljs-string">{this.didPress}</span>&gt;</span>
          <span class="hljs-tag">&lt;<span class="hljs-name">Text</span>&gt;</span>Load<span class="hljs-tag">&lt;/<span class="hljs-name">Text</span>&gt;</span>
        <span class="hljs-tag">&lt;/<span class="hljs-name">TouchableOpacity</span>&gt;</span>
        {this.state.needsExpensive ? <span class="hljs-tag">&lt;<span class="hljs-name">VeryExpensive</span> /&gt;</span> : null}
      <span class="hljs-tag">&lt;/<span class="hljs-name">View</span>&gt;</span></span>
    );
  }
}
</code></pre>
<p>即便不使用 RAM 格式，内联引用也会使启动时间减少，因为优化后的代码只有在第一次 require 时才会执行。</p>
<h3><a class="anchor" aria-hidden="true" id="启用-ram-格式"></a><a href="#启用-ram-格式" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>启用 RAM 格式</h3>
<p>在 iOS 上使用 RAM 格式将创建一个简单的索引文件，React Native 将根据此文件一次加载一个模块。在 Android 上，默认情况下它会为每个模块创建一组文件。你可以像 iOS 一样，强制 Android 只创建一个文件，但使用多个文件可以提高性能，并降低内存占用。</p>
<p>在 Xcode 中启用 RAM 格式，需要编辑 build phase 里的&quot;Bundle React Native code and images&quot;。在<code>../node_modules/react-native/scripts/react-native-xcode.sh</code>中添加 <code>export BUNDLE_COMMAND=&quot;ram-bundle&quot;</code>:</p>
<pre><code class="hljs"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">BUNDLE_COMMAND</span>=<span class="hljs-string">"ram-bundle"</span>
<span class="hljs-builtin-name">export</span> <span class="hljs-attribute">NODE_BINARY</span>=node
<span class="hljs-built_in">..</span>/node_modules/react-native/scripts/react-native-xcode.sh
</code></pre>
<p>在 Android 上启用 RAM 格式，需要编辑 android/app/build.gradle 文件。在<code>apply from: &quot;../../node_modules/react-native/react.gradle&quot;</code>之前修改或添加<code>project.ext.react</code>：</p>
<pre><code class="hljs"><span class="hljs-attr">project.ext.react</span> = [
  bundleCommand: <span class="hljs-string">"ram-bundle"</span>,
]
</code></pre>
<p>如果在 Android 上，你想使用单个索引文件（如前所述），请在 Android 上使用以下行：</p>
<pre><code class="hljs">project.ext.react = [
<span class="hljs-symbol">  bundleCommand:</span> <span class="hljs-string">"ram-bundle"</span>,
<span class="hljs-symbol">  extraPackagerArgs:</span> [<span class="hljs-string">"--indexed-ram-bundle"</span>]
]
</code></pre>
<blockquote>
<p><strong><em>Note</em></strong>: If you are using <a href="https://github.com/facebook/hermes">Hermes JS Engine</a>, you do not need RAM bundles. When loading the bytecode, <code>mmap</code> ensures that the entire file is not loaded.</p>
</blockquote>
<h3><a class="anchor" aria-hidden="true" id="配置预加载及内联引用"></a><a href="#配置预加载及内联引用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>配置预加载及内联引用</h3>
<p>现在我们已经启用了RAM格式，然而调用<code>require</code>会造成额外的开销。因为当遇到尚未加载的模块时，<code>require</code>需要通过bridge来发送消息。这主要会影响到启动速度，因为在应用程序加载初始模块时可能触发相当大量的请求调用。幸运的是，我们可以配置一部分模块进行预加载。为了做到这一点，你将需要实现某种形式的内联引用。</p>
<h3><a class="anchor" aria-hidden="true" id="调试预加载的模块"></a><a href="#调试预加载的模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>调试预加载的模块</h3>
<p>在您的根文件 (index.(ios|android).js) 中，您可以在初始导入(initial imports)之后添加以下内容：</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> modules = <span class="hljs-built_in">require</span>.getModules();
<span class="hljs-keyword">const</span> moduleIds = <span class="hljs-built_in">Object</span>.keys(modules);
<span class="hljs-keyword">const</span> loadedModuleNames = moduleIds
  .filter(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> modules[moduleId].isInitialized)
  .map(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> modules[moduleId].verboseName);
<span class="hljs-keyword">const</span> waitingModuleNames = moduleIds
  .filter(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> !modules[moduleId].isInitialized)
  .map(<span class="hljs-function"><span class="hljs-params">moduleId</span> =&gt;</span> modules[moduleId].verboseName);

<span class="hljs-comment">// make sure that the modules you expect to be waiting are actually waiting</span>
<span class="hljs-built_in">console</span>.log(
  <span class="hljs-string">'loaded:'</span>,
  loadedModuleNames.length,
  <span class="hljs-string">'waiting:'</span>,
  waitingModuleNames.length
);

<span class="hljs-comment">// grab this text blob, and put it in a file named packager/modulePaths.js</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`module.exports = <span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify(loadedModuleNames.sort())}</span>;`</span>);
</code></pre>
<p>当你运行你的应用程序时，你可以查看 console 控制台，有多少模块已经加载，有多少模块在等待。你可能想查看 moduleNames，看看是否有任何意外。注意在首次 import 时调用的内联引用。你可能需要检查和重构，以确保只有你想要的模块在启动时加载。请注意，您可以根据需要修改 Systrace 对象，以帮助调试有问题的引用。</p>
<pre><code class="hljs"><span class="hljs-built_in">require</span>.Systrace.beginEvent = <span class="hljs-function"><span class="hljs-params">(message)</span> =&gt;</span> {
  <span class="hljs-keyword">if</span>(message.includes(problematicModule)) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error();
  }
}
</code></pre>
<p>虽然每个 App 各有不同，但只加载第一个页面所需的模块是有普适意义的。当你满意时，把 loadedModuleNames 的输出放到 packager/modulePaths.js 文件中。</p>
<h3><a class="anchor" aria-hidden="true" id="更新配置文件metroconfigjs"></a><a href="#更新配置文件metroconfigjs" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更新配置文件(metro.config.js)</h3>
<p>We now need to update <code>metro.config.js</code> in the root of the project to use our newly generated <code>modulePaths.js</code> file:</p>
<pre><code class="hljs"><span class="hljs-keyword">const</span> modulePaths = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./packager/modulePaths'</span>);
<span class="hljs-keyword">const</span> resolve = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>).resolve;
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-comment">// Update the following line if the root folder of your app is somewhere else.</span>
<span class="hljs-keyword">const</span> ROOT_FOLDER = resolve(__dirname, <span class="hljs-string">'..'</span>);

<span class="hljs-keyword">const</span> config = {
  <span class="hljs-attr">transformer</span>: {
    <span class="hljs-attr">getTransformOptions</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
      <span class="hljs-keyword">const</span> moduleMap = {};
      modulePaths.forEach(<span class="hljs-function"><span class="hljs-params">path</span> =&gt;</span> {
        <span class="hljs-keyword">if</span> (fs.existsSync(path)) {
          moduleMap[resolve(path)] = <span class="hljs-literal">true</span>;
        }
      });
      <span class="hljs-keyword">return</span> {
        <span class="hljs-attr">preloadedModules</span>: moduleMap,
        <span class="hljs-attr">transform</span>: { <span class="hljs-attr">inlineRequires</span>: { <span class="hljs-attr">blacklist</span>: moduleMap } },
      };
    },
  },
  <span class="hljs-attr">projectRoot</span>: ROOT_FOLDER,
};

<span class="hljs-built_in">module</span>.exports = config;
</code></pre>
<p>在启用RAM格式之后，配置文件中的<code>preloadedModules</code>条目指示哪些模块需要预加载。当 bundle 被加载时，这些模块立即被加载，甚至在任何 requires 执行之前。blacklist 表明这些模块不应该被要求内联引用，因为它们是预加载的，所以使用内联没有性能优势。实际上每次解析内联引用 JavaScript 都会花费额外的时间。</p>
<h3><a class="anchor" aria-hidden="true" id="测试和衡量改进"></a><a href="#测试和衡量改进" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>测试和衡量改进</h3>
<p>您现在应该准备好使用RAM格式和内联引用来构建您的应用了。保存启动前后的时间，来测试下有多少改进吧！</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/0.61/debugging"><span class="arrow-prev">← </span><span>调试</span></a><a class="docs-next button" href="/docs/0.61/gesture-responder-system"><span>手势响应系统</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#关于帧你所需要知道的">关于“帧”你所需要知道的</a><ul class="toc-headings"><li><a href="#js-帧率javascript-线程">JS 帧率(JavaScript 线程)</a></li><li><a href="#ui-帧率主线程">UI 帧率(主线程)</a></li></ul></li><li><a href="#性能问题的常见原因">性能问题的常见原因</a><ul class="toc-headings"><li><a href="#开发模式-devtrue">开发模式 (<code>dev=true</code>)</a></li><li><a href="#consolelog-语句">console.log 语句</a></li><li><a href="#listview-首次渲染缓慢或者由于列表很大导致滑动很慢"><code>ListView</code> 首次渲染缓慢或者由于列表很大导致滑动很慢</a></li><li><a href="#在重绘一个几乎没有什么变化的页面时，js-帧率严重降低">在重绘一个几乎没有什么变化的页面时，JS 帧率严重降低</a></li><li><a href="#在屏幕上移动视图（滚动，切换，旋转）时，ui-线程掉帧">在屏幕上移动视图（滚动，切换，旋转）时，UI 线程掉帧</a></li><li><a href="#使用动画改变图片的尺寸时，ui-线程掉帧">使用动画改变图片的尺寸时，UI 线程掉帧</a></li><li><a href="#touchable-系列组件不能很好的响应">Touchable 系列组件不能很好的响应</a></li></ul></li><li><a href="#分析">分析</a><ul class="toc-headings"><li><a href="#使用-systrace-调试-android-ui-性能">使用 systrace 调试 Android UI 性能</a></li></ul></li><li><a href="#拆包ram-bundles和内联引用">拆包(RAM bundles)和内联引用</a><ul class="toc-headings"><li><a href="#加载-javascript">加载 JavaScript</a></li><li><a href="#内联引用">内联引用</a></li><li><a href="#启用-ram-格式">启用 RAM 格式</a></li><li><a href="#配置预加载及内联引用">配置预加载及内联引用</a></li><li><a href="#调试预加载的模块">调试预加载的模块</a></li><li><a href="#更新配置文件metroconfigjs">更新配置文件(metro.config.js)</a></li><li><a href="#测试和衡量改进">测试和衡量改进</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright"><p style="color:inherit">React Native中文网 © 2020 武汉青罗网络科技有限公司</p><p style="color:inherit"><a href="http://beian.miit.gov.cn/">鄂ICP备20002031号</a><img src="https://img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png" alt="鄂公网安备 42011202001821号"/><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42011202001821">鄂公网安备 42011202001821号</a></p></section><script>
        (function(){
          var c = document.createElement("div");
          c.setAttribute("id", "lv-container");
          c.setAttribute("data-id", "city");
          c.setAttribute("data-uid", "MTAyMC8zODM4NS8xNDkxMw==");
          var container = document.querySelector(".mainContainer")
          container && container.appendChild(c);
        })()
        </script><script src="https://cdn-city.livere.com/js/embed.dist.js"></script></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '7ab53ed26928639bae06ef0f6165f68b',
                indexName: 'reactnative_cn',
                inputSelector: '#search_input_react',
                algoliaOptions: {"hitsPerPage":5}
              });
            </script></body></html>