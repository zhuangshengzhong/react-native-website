<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>原生模块 · React Native 中文网</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。"/><meta name="docsearch:version" content="next"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="原生模块 · React Native 中文网"/><meta property="og:type" content="website"/><meta property="og:url" content="undefined/"/><meta property="og:description" content="有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/highlight.js@9.18.1/styles/solarized-dark.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-63485149-4', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/focus-visible@5.0.2/dist/focus-visible.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/codeblocks.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/tabs.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/doccode0325.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/snack.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-back-to-top@7.1.14/dist/vanilla-back-to-top.min.js"></script><script>
        document.addEventListener('DOMContentLoaded', function() {
          addBackToTop(
            {"zIndex":100}
          )
        });
        </script><script src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/scrollSpy.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/css/main.css"/><script src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="https://cdn.jsdelivr.net/gh/reactnativecn/react-native-website@gh-pages/img/header_logo.svg" alt="React Native 中文网"/><h2 class="headerTitleWithLogo">React Native 中文网</h2></a><a href="/versions"><h3>next</h3></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/docs/next/getting-started" target="_self">文档</a></li><li class=""><a href="/docs/next/activityindicator" target="_self">API</a></li><li class=""><a href="//github.com/reactnativecn/react-native-website/issues" target="_blank">讨论</a></li><li class=""><a href="//pushy.reactnative.cn" target="_blank">热更新</a></li><li class=""><a href="/about" target="_self">关于</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li><li class=""><a href="https://github.com/facebook/react-native" target="_self">GitHub</a></li><li class=""><a href="//zh-hans.reactjs.org/" target="_blank">React</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>使用指南(Android)</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">入门基础<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/getting-started">搭建开发环境</a></li><li class="navListItem"><a class="navItem" href="/docs/next/intro-react-native-components">核心组件与原生组件</a></li><li class="navListItem"><a class="navItem" href="/docs/next/intro-react">React基础</a></li><li class="navListItem"><a class="navItem" href="/docs/next/tutorial">示例教程：Hello World</a></li><li class="navListItem"><a class="navItem" href="/docs/next/props">Props（属性）</a></li><li class="navListItem"><a class="navItem" href="/docs/next/state">State（状态）</a></li><li class="navListItem"><a class="navItem" href="/docs/next/handling-text-input">处理文本输入</a></li><li class="navListItem"><a class="navItem" href="/docs/next/handling-touches">处理触摸事件</a></li><li class="navListItem"><a class="navItem" href="/docs/next/using-a-scrollview">使用滚动视图</a></li><li class="navListItem"><a class="navItem" href="/docs/next/using-a-listview">使用长列表</a></li><li class="navListItem"><a class="navItem" href="/docs/next/network">网络</a></li><li class="navListItem"><a class="navItem" href="/docs/next/sample-application-movies">示例教程：电影列表</a></li><li class="navListItem"><a class="navItem" href="/docs/next/more-resources">其他参考资源</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">设计<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/style">样式</a></li><li class="navListItem"><a class="navItem" href="/docs/next/height-and-width">高度与宽度</a></li><li class="navListItem"><a class="navItem" href="/docs/next/flexbox">使用Flexbox布局</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">进阶指南<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/components-and-apis">核心组件和API</a></li><li class="navListItem"><a class="navItem" href="/docs/next/fast-refresh">快速刷新</a></li><li class="navListItem"><a class="navItem" href="/docs/next/platform-specific-code">特定平台代码</a></li><li class="navListItem"><a class="navItem" href="/docs/next/navigation">使用导航器跳转页面</a></li><li class="navListItem"><a class="navItem" href="/docs/next/images">图片</a></li><li class="navListItem"><a class="navItem" href="/docs/next/animations">动画</a></li><li class="navListItem"><a class="navItem" href="/docs/next/accessibility">无障碍功能</a></li><li class="navListItem"><a class="navItem" href="/docs/next/improvingux">改进用户体验</a></li><li class="navListItem"><a class="navItem" href="/docs/next/optimizing-flatlist-configuration">列表配置优化</a></li><li class="navListItem"><a class="navItem" href="/docs/next/timers">定时器</a></li><li class="navListItem"><a class="navItem" href="/docs/next/debugging">调试</a></li><li class="navListItem"><a class="navItem" href="/docs/next/performance">性能</a></li><li class="navListItem"><a class="navItem" href="/docs/next/gesture-responder-system">手势响应系统</a></li><li class="navListItem"><a class="navItem" href="/docs/next/javascript-environment">JavaScript环境</a></li><li class="navListItem"><a class="navItem" href="/docs/next/typescript">使用TypeScript</a></li><li class="navListItem"><a class="navItem" href="/docs/next/direct-manipulation">直接操作</a></li><li class="navListItem"><a class="navItem" href="/docs/next/colors">颜色</a></li><li class="navListItem"><a class="navItem" href="/docs/next/integration-with-existing-apps">集成到现有原生应用</a></li><li class="navListItem"><a class="navItem" href="/docs/next/building-for-tv">为电视和机顶盒制作应用</a></li><li class="navListItem"><a class="navItem" href="/docs/next/running-on-device">在设备上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/next/upgrading">更新</a></li><li class="navListItem"><a class="navItem" href="/docs/next/native-modules-setup">原生模块配置</a></li><li class="navListItem"><a class="navItem" href="/docs/next/out-of-tree-platforms">多平台支持</a></li><li class="navListItem"><a class="navItem" href="/docs/next/building-from-source">从源代码编译React Native</a></li><li class="navListItem"><a class="navItem" href="/docs/next/publishing-forks">发布自己定制的ReactNative包</a></li><li class="navListItem"><a class="navItem" href="/docs/next/testing">Testing your Changes</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(iOS)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem"><a class="navItem" href="/docs/next/native-modules-ios">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/next/native-components-ios">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/next/linking-libraries-ios">链接原生库</a></li><li class="navListItem"><a class="navItem" href="/docs/next/running-on-simulator-ios">在iOS模拟器上运行</a></li><li class="navListItem"><a class="navItem" href="/docs/next/communication-ios">和原生端通信</a></li><li class="navListItem"><a class="navItem" href="/docs/next/app-extensions">iOS应用扩展</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle collapsible">使用指南(Android)<span class="arrow"><svg width="24" height="24" viewBox="0 0 24 24"><path fill="#565656" d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></h3><ul class="hide"><li class="navListItem navListItemActive"><a class="navItem" href="/docs/next/native-modules-android">原生模块</a></li><li class="navListItem"><a class="navItem" href="/docs/next/native-components-android">原生UI组件</a></li><li class="navListItem"><a class="navItem" href="/docs/next/headless-js-android">Headless JS（后台任务）</a></li><li class="navListItem"><a class="navItem" href="/docs/next/signed-apk-android">打包APK</a></li><li class="navListItem"><a class="navItem" href="/docs/next/removing-default-permissions">移除不需要的权限</a></li><li class="navListItem"><a class="navItem" href="/docs/next/hermes">Using Hermes</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="//github.com/reactnativecn/react-native-website/blob/production/cndocs/native-modules-android.md" target="_blank" rel="noreferrer noopener">帮助改进此文档</a><h1 id="__docusaurus" class="postHeaderTitle">原生模块</h1></header><article><div><span><p>有时候 App 需要访问平台 API，但 React Native 可能还没有相应的模块包装；或者你需要复用一些 Java 代码，而不是用 Javascript 重新实现一遍；又或者你需要实现某些高性能的、多线程的代码，譬如图片处理、数据库、或者各种高级扩展等等。</p>
<p>我们把 React Native 设计为可以在其基础上编写真正的原生代码，并且可以访问平台所有的能力。这是一个相对高级的特性，我们并不认为它应当在日常开发的过程中经常出现，但具备这样的能力是很重要的。如果 React Native 还不支持某个你需要的原生特性，你应当可以自己实现该特性的封装。</p>
<h2><a class="anchor" aria-hidden="true" id="native-module-setup"></a><a href="#native-module-setup" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Native Module Setup</h2>
<p>Native modules are usually distributed as npm packages, apart from the typical javascript files and resources they will contain an Android library project. This project is, from NPM's perspective just like any other media asset, meaning there isn't anything special about it from this point of view. To get the basic scaffolding make sure to read <a href="native-modules-setup">Native Modules Setup</a> guide first.</p>
<h3><a class="anchor" aria-hidden="true" id="开启-gradle-daemon"></a><a href="#开启-gradle-daemon" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>开启 Gradle Daemon</h3>
<p>我们建议开启<a href="https://docs.gradle.org/2.9/userguide/gradle_daemon.html">Gradle Daemon</a>来加速 Java 代码编译。</p>
<h2><a class="anchor" aria-hidden="true" id="toast-模块"></a><a href="#toast-模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Toast 模块</h2>
<p>本向导会用<a href="http://developer.android.com/reference/android/widget/Toast.html">Toast</a>作为例子。假设我们希望可以从 Javascript 发起一个 Toast 消息（一种会在屏幕下方弹出、保持一段时间的消息通知）。</p>
<p>我们首先来创建一个原生模块。一个原生模块是一个继承了<code>ReactContextBaseJavaModule</code>的 Java 类，它可以实现一些 JavaScript 所需的功能。我们这里的目标是可以在 JavaScript 里写<code>ToastExample.show('Awesome', ToastExample.SHORT);</code>，来调起一个短暂的 Toast 通知。</p>
<p>创建一个新的 Java 类并命名为<code>ToastModule.java</code>，放置到<code>android/app/src/main/java/com/your-app-name/</code>目录下，其具体代码如下：</p>
<pre><code class="hljs css language-java"><span class="hljs-comment">// ToastModule.java</span>

<span class="hljs-keyword">package</span> com.your-app-name;

<span class="hljs-keyword">import</span> android.widget.Toast;

<span class="hljs-keyword">import</span> com.facebook.react.bridge.NativeModule;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.ReactApplicationContext;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.ReactContext;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.ReactContextBaseJavaModule;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.ReactMethod;

<span class="hljs-keyword">import</span> java.util.Map;
<span class="hljs-keyword">import</span> java.util.HashMap;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ToastModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactContextBaseJavaModule</span> </span>{
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ReactApplicationContext reactContext;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DURATION_SHORT_KEY = <span class="hljs-string">"SHORT"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DURATION_LONG_KEY = <span class="hljs-string">"LONG"</span>;

  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ToastModule</span><span class="hljs-params">(ReactApplicationContext reactContext)</span> </span>{
    <span class="hljs-keyword">super</span>(reactContext);
    reactContext = context;
  }
}
</code></pre>
<p><code>ReactContextBaseJavaModule</code>要求派生类实现<code>getName</code>方法。这个函数用于返回一个字符串名字，这个名字在 JavaScript 端标记这个模块。这里我们把这个模块叫做<code>ToastExample</code>，这样就可以在 JavaScript 中通过<code>NativeModules.ToastExample</code>访问到这个模块。<strong>译注：RN 已经内置了一个名为 ToastAndroid 的模块，所以在练习时请勿使用 ToastAndroid 的名字，否则运行时会报错名字冲突！</strong></p>
<pre><code class="hljs css language-java">  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"ToastExample"</span>;
  }
</code></pre>
<p>一个可选的方法<code>getContants</code>返回了需要导出给 JavaScript 使用的常量。它并不一定需要实现，但在定义一些可以被 JavaScript 同步访问到的预定义的值时非常有用。</p>
<pre><code class="hljs css language-java">  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getConstants</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; constants = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();
    constants.put(DURATION_SHORT_KEY, Toast.LENGTH_SHORT);
    constants.put(DURATION_LONG_KEY, Toast.LENGTH_LONG);
    <span class="hljs-keyword">return</span> constants;
  }
</code></pre>
<p>要导出一个方法给 JavaScript 使用，Java 方法需要使用注解<code>@ReactMethod</code>。方法的返回类型必须为<code>void</code>。React Native 的跨语言访问是异步进行的，所以想要给 JavaScript 返回一个值的唯一办法是使用回调函数或者发送事件（参见下文的描述）。</p>
<pre><code class="hljs css language-java">  <span class="hljs-meta">@ReactMethod</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">(String message, <span class="hljs-keyword">int</span> duration)</span> </span>{
    Toast.makeText(getReactApplicationContext(), message, duration).show();
  }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="参数类型"></a><a href="#参数类型" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参数类型</h3>
<p>下面的参数类型在<code>@ReactMethod</code>注明的方法中，会被直接映射到它们对应的 JavaScript 类型。</p>
<pre><code class="hljs css language-text">Boolean -> Bool
Integer -> Number
Double -> Number
Float -> Number
String -> String
Callback -> function
ReadableMap -> Object
ReadableArray -> Array
</code></pre>
<p>参阅<a href="https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/ReadableMap.java">ReadableMap</a>和<a href="https://github.com/facebook/react-native/blob/master/ReactAndroid/src/main/java/com/facebook/react/bridge/ReadableArray.java">ReadableArray</a>。</p>
<h3><a class="anchor" aria-hidden="true" id="注册模块"></a><a href="#注册模块" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>注册模块</h3>
<p>在 Java 这边要做的最后一件事就是注册这个模块。我们需要在应用的 Package 类的<code>createNativeModules</code>方法中添加这个模块。如果模块没有被注册，它也无法在 JavaScript 中被访问到。</p>
<p>创建一个新的 Java 类并命名为<code>CustomToastPackage.java</code>，放置到<code>android/app/src/main/java/com/your-app-name/</code>目录下，其具体代码如下：</p>
<pre><code class="hljs css language-java"><span class="hljs-comment">// CustomToastPackage.java</span>

<span class="hljs-keyword">package</span> com.your-app-name;

<span class="hljs-keyword">import</span> com.facebook.react.ReactPackage;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.NativeModule;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.ReactApplicationContext;
<span class="hljs-keyword">import</span> com.facebook.react.uimanager.ViewManager;

<span class="hljs-keyword">import</span> java.util.ArrayList;
<span class="hljs-keyword">import</span> java.util.Collections;
<span class="hljs-keyword">import</span> java.util.List;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomToastPackage</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ReactPackage</span> </span>{

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ViewManager&gt; <span class="hljs-title">createViewManagers</span><span class="hljs-params">(ReactApplicationContext reactContext)</span> </span>{
    <span class="hljs-keyword">return</span> Collections.emptyList();
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;NativeModule&gt; <span class="hljs-title">createNativeModules</span><span class="hljs-params">(
                              ReactApplicationContext reactContext)</span> </span>{
    List&lt;NativeModule&gt; modules = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();

    modules.add(<span class="hljs-keyword">new</span> ToastModule(reactContext));

    <span class="hljs-keyword">return</span> modules;
  }

}
</code></pre>
<p>这个 package 需要在<code>MainApplication.java</code>文件的<code>getPackages</code>方法中提供。这个文件位于你的 react-native 应用文件夹的 android 目录中。具体路径是: <code>android/app/src/main/java/com/your-app-name/MainApplication.java</code>.</p>
<pre><code class="hljs css language-java"><span class="hljs-comment">// MainApplication.java</span>
...
<span class="hljs-keyword">import</span> com.your-app-name.CustomToastPackage; <span class="hljs-comment">// &lt;-- 引入你自己的包</span>
...
<span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;ReactPackage&gt; <span class="hljs-title">getPackages</span><span class="hljs-params">()</span> </span>{
  <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">"UnnecessaryLocalVariable"</span>)
  List&lt;ReactPackage&gt; packages = <span class="hljs-keyword">new</span> PackageList(<span class="hljs-keyword">this</span>).getPackages();
  <span class="hljs-comment">// Packages that cannot be autolinked yet can be added manually here, for example:</span>
  <span class="hljs-comment">// packages.add(new MyReactNativePackage());</span>
  packages.add(<span class="hljs-keyword">new</span> CustomToastPackage()); <span class="hljs-comment">// &lt;-- 添加这一行，类名替换成你的Package类的名字 name.</span>
  <span class="hljs-keyword">return</span> packages;
}
</code></pre>
<p>为了让你的功能从 JavaScript 端访问起来更为方便，通常我们都会把原生模块封装成一个 JavaScript 模块。这不是必须的，但省下了每次都从<code>NativeModules</code>中获取对应模块的步骤。这个 JS 文件也可以用于添加一些其他 JavaScript 端实现的功能。</p>
<pre><code class="hljs css language-jsx"><span class="hljs-comment">// ToastExample.js</span>
<span class="hljs-comment">/**
 * This exposes the native ToastExample module as a JS module. This has a
 * function 'show' which takes the following parameters:
 *
 * 1. String message: A string with the text to toast
 * 2. int duration: The duration of the toast. May be ToastExample.SHORT or
 *    ToastExample.LONG
 */</span>
<span class="hljs-keyword">import</span> { NativeModules } <span class="hljs-keyword">from</span> <span class="hljs-string">"react-native"</span>;
<span class="hljs-comment">// 下一句中的ToastExample即对应上文</span>
<span class="hljs-comment">// public String getName()中返回的字符串</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> NativeModules.ToastExample;
</code></pre>
<p>现在，在别处的 JavaScript 代码中可以这样调用你的方法：</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> ToastExample <span class="hljs-keyword">from</span> <span class="hljs-string">"./ToastExample"</span>;

ToastExample.show(<span class="hljs-string">"Awesome"</span>, ToastExample.SHORT);
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="更多特性"></a><a href="#更多特性" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更多特性</h2>
<h3><a class="anchor" aria-hidden="true" id="回调函数"></a><a href="#回调函数" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>回调函数</h3>
<p>原生模块还支持一种特殊的参数——回调函数。它提供了一个函数来把返回值传回给 JavaScript。</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">import</span> com.facebook.react.bridge.Callback;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UIManagerModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactContextBaseJavaModule</span> </span>{

...

  <span class="hljs-meta">@ReactMethod</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureLayout</span><span class="hljs-params">(
      <span class="hljs-keyword">int</span> tag,
      <span class="hljs-keyword">int</span> ancestorTag,
      Callback errorCallback,
      Callback successCallback)</span> </span>{
    <span class="hljs-keyword">try</span> {
      measureLayout(tag, ancestorTag, mMeasureBuffer);
      <span class="hljs-keyword">float</span> relativeX = PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">0</span>]);
      <span class="hljs-keyword">float</span> relativeY = PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">1</span>]);
      <span class="hljs-keyword">float</span> width = PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">2</span>]);
      <span class="hljs-keyword">float</span> height = PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">3</span>]);
      successCallback.invoke(relativeX, relativeY, width, height);
    } <span class="hljs-keyword">catch</span> (IllegalViewOperationException e) {
      errorCallback.invoke(e.getMessage());
    }
  }

...
</code></pre>
<p>这个函数可以在 JavaScript 里这样使用：</p>
<pre><code class="hljs css language-jsx">UIManager.measureLayout(
  <span class="hljs-number">100</span>,
  <span class="hljs-number">100</span>,
  msg =&gt; {
    <span class="hljs-built_in">console</span>.log(msg);
  },
  (x, y, width, height) =&gt; {
    <span class="hljs-built_in">console</span>.log(x + <span class="hljs-string">":"</span> + y + <span class="hljs-string">":"</span> + width + <span class="hljs-string">":"</span> + height);
  }
);
</code></pre>
<p>原生模块通常只应调用回调函数一次。但是，它可以保存 callback 并在将来调用。</p>
<p>请务必注意 callback 并非在对应的原生函数返回后立即被执行——注意跨语言通讯是异步的，这个执行过程会通过消息循环来进行。</p>
<h3><a class="anchor" aria-hidden="true" id="promises"></a><a href="#promises" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Promises</h3>
<p>Promises</p>
<p><strong>译注</strong>：这一部分涉及到较新的 js 语法和特性，不熟悉的读者建议先阅读 ES6 的相关书籍和文档。</p>
<p>原生模块还可以使用 promise 来简化代码，搭配 ES2016(ES7)标准的<code>async/await</code>语法则效果更佳。如果桥接原生方法的最后一个参数是一个<code>Promise</code>，则对应的 JS 方法就会返回一个 Promise 对象。</p>
<p>我们把上面的代码用 promise 来代替回调进行重构：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">import</span> com.facebook.react.bridge.Promise;

<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UIManagerModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactContextBaseJavaModule</span> </span>{

...
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String E_LAYOUT_ERROR = <span class="hljs-string">"E_LAYOUT_ERROR"</span>;
  <span class="hljs-meta">@ReactMethod</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">measureLayout</span><span class="hljs-params">(
      <span class="hljs-keyword">int</span> tag,
      <span class="hljs-keyword">int</span> ancestorTag,
      Promise promise)</span> </span>{
    <span class="hljs-keyword">try</span> {
      measureLayout(tag, ancestorTag, mMeasureBuffer);

      WritableMap map = Arguments.createMap();

      map.putDouble(<span class="hljs-string">"relativeX"</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">0</span>]));
      map.putDouble(<span class="hljs-string">"relativeY"</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">1</span>]));
      map.putDouble(<span class="hljs-string">"width"</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">2</span>]));
      map.putDouble(<span class="hljs-string">"height"</span>, PixelUtil.toDIPFromPixel(mMeasureBuffer[<span class="hljs-number">3</span>]));

      promise.resolve(map);
    } <span class="hljs-keyword">catch</span> (IllegalViewOperationException e) {
      promise.reject(E_LAYOUT_ERROR, e);
    }
  }

...
</code></pre>
<p>现在 JavaScript 端的方法会返回一个 Promise。这样你就可以在一个声明了<code>async</code>的异步函数内使用<code>await</code>关键字来调用，并等待其结果返回。（虽然这样写着看起来像同步操作，但实际仍然是异步的，并不会阻塞执行来等待）。</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">measureLayout</span>(<span class="hljs-params"></span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> { relativeX, relativeY, width, height } = <span class="hljs-keyword">await</span> UIManager.measureLayout(
      <span class="hljs-number">100</span>,
      <span class="hljs-number">100</span>
    );

    <span class="hljs-built_in">console</span>.log(relativeX + <span class="hljs-string">":"</span> + relativeY + <span class="hljs-string">":"</span> + width + <span class="hljs-string">":"</span> + height);
  } <span class="hljs-keyword">catch</span> (e) {
    <span class="hljs-built_in">console</span>.error(e);
  }
}

measureLayout();
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="多线程"></a><a href="#多线程" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多线程</h3>
<p>原生模块不应对自己被调用时所处的线程做任何假设，当前的状况有可能会在将来的版本中改变。如果一个过程要阻塞执行一段时间，这个工作应当分配到一个内部管理的工作线程，然后从那边可以调用任意的回调函数。<em>译注</em>：我们通常用 AsyncTask 来完成这项工作。</p>
<h3><a class="anchor" aria-hidden="true" id="发送事件到-javascript"></a><a href="#发送事件到-javascript" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>发送事件到 JavaScript</h3>
<p>原生模块可以在没有被调用的情况下往 JavaScript 发送事件通知。最简单的办法就是通过<code>RCTDeviceEventEmitter</code>，这可以通过<code>ReactContext</code>来获得对应的引用，像这样：</p>
<pre><code class="hljs css language-java">...
<span class="hljs-keyword">import</span> com.facebook.react.modules.core.DeviceEventManagerModule;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.WritableMap;
<span class="hljs-keyword">import</span> com.facebook.react.bridge.Arguments;
...
<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendEvent</span><span class="hljs-params">(ReactContext reactContext,
                       String eventName,
                       @Nullable WritableMap params)</span> </span>{
  reactContext
      .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter<span class="hljs-class">.<span class="hljs-keyword">class</span>)
      .<span class="hljs-title">emit</span>(<span class="hljs-title">eventName</span>, <span class="hljs-title">params</span>)</span>;
}
...
WritableMap params = Arguments.createMap();
params.putString(<span class="hljs-string">"eventProperty"</span>, <span class="hljs-string">"someValue"</span>);
...
sendEvent(reactContext, <span class="hljs-string">"EventReminder"</span>, params);
</code></pre>
<p>JavaScript 模块可以通过使用<code>NativeEventEmitter</code>模块来监听事件：</p>
<pre><code class="hljs css language-jsx"><span class="hljs-keyword">import</span> { NativeEventEmitter, NativeModules } <span class="hljs-keyword">from</span> <span class="hljs-string">'react-native'</span>;
<span class="hljs-comment">// ...</span>

  componentDidMount() {
    <span class="hljs-comment">// ...</span>
    <span class="hljs-keyword">const</span> eventEmitter = <span class="hljs-keyword">new</span> NativeEventEmitter(NativeModules.ToastExample);
    <span class="hljs-keyword">this</span>.eventEmitter = eventEmitter.addListener(<span class="hljs-string">'EventReminder'</span>, (event) =&gt; {
       <span class="hljs-built_in">console</span>.log(event.eventProperty) <span class="hljs-comment">// "someValue"</span>
    };
    <span class="hljs-comment">// ...</span>
  }
  componentWillUnmount() {
    <span class="hljs-keyword">this</span>.eventListener.remove(); <span class="hljs-comment">// Removes the listener</span>
  }
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="从startactivityforresult中获取结果"></a><a href="#从startactivityforresult中获取结果" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>从<code>startActivityForResult</code>中获取结果</h3>
<p>如果你使用<code>startActivityForResult</code>调起了一个 activity 并想从其中获取返回结果，那么你需要监听<code>onActivityResult</code>事件。具体的做法是继承<code>BaseActivityEventListener</code>或是实现<code>ActivityEventListener</code>。我们推荐前一种做法，因为它相对来说不太会受到 API 变更的影响。然后你需要在模块的构造函数中注册这一监听事件。</p>
<pre><code class="hljs css language-java">reactContext.addActivityEventListener(mActivityResultListener);
</code></pre>
<p>现在你可以通过重写下面的方法来实现对<code>onActivityResult</code>的监听：</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(
  <span class="hljs-keyword">final</span> Activity activity,
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> requestCode,
  <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> resultCode,
  <span class="hljs-keyword">final</span> Intent intent)</span> </span>{
  <span class="hljs-comment">// 在这里实现你自己的逻辑</span>
}
</code></pre>
<p>下面我们写一个简单的图片选择器来实践一下。这个图片选择器会把<code>pickImage</code>方法暴露给 JavaScript，而这个方法在调用时就会把图片的路径返回到 JS 端。</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ImagePickerModule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReactContextBaseJavaModule</span> </span>{

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> IMAGE_PICKER_REQUEST = <span class="hljs-number">467081</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String E_ACTIVITY_DOES_NOT_EXIST = <span class="hljs-string">"E_ACTIVITY_DOES_NOT_EXIST"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String E_PICKER_CANCELLED = <span class="hljs-string">"E_PICKER_CANCELLED"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String E_FAILED_TO_SHOW_PICKER = <span class="hljs-string">"E_FAILED_TO_SHOW_PICKER"</span>;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String E_NO_IMAGE_DATA_FOUND = <span class="hljs-string">"E_NO_IMAGE_DATA_FOUND"</span>;

  <span class="hljs-keyword">private</span> Promise mPickerPromise;

  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ActivityEventListener mActivityEventListener = <span class="hljs-keyword">new</span> BaseActivityEventListener() {

    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onActivityResult</span><span class="hljs-params">(Activity activity, <span class="hljs-keyword">int</span> requestCode, <span class="hljs-keyword">int</span> resultCode, Intent intent)</span> </span>{
      <span class="hljs-keyword">if</span> (requestCode == IMAGE_PICKER_REQUEST) {
        <span class="hljs-keyword">if</span> (mPickerPromise != <span class="hljs-keyword">null</span>) {
          <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_CANCELED) {
            mPickerPromise.reject(E_PICKER_CANCELLED, <span class="hljs-string">"Image picker was cancelled"</span>);
          } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (resultCode == Activity.RESULT_OK) {
            Uri uri = intent.getData();

            <span class="hljs-keyword">if</span> (uri == <span class="hljs-keyword">null</span>) {
              mPickerPromise.reject(E_NO_IMAGE_DATA_FOUND, <span class="hljs-string">"No image data found"</span>);
            } <span class="hljs-keyword">else</span> {
              mPickerPromise.resolve(uri.toString());
            }
          }

          mPickerPromise = <span class="hljs-keyword">null</span>;
        }
      }
    }
  };

  ImagePickerModule(ReactApplicationContext reactContext) {
    <span class="hljs-keyword">super</span>(reactContext);

    <span class="hljs-comment">// Add the listener for `onActivityResult`</span>
    reactContext.addActivityEventListener(mActivityEventListener);
  }

  <span class="hljs-meta">@Override</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-keyword">return</span> <span class="hljs-string">"ImagePickerModule"</span>;
  }

  <span class="hljs-meta">@ReactMethod</span>
  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pickImage</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Promise promise)</span> </span>{
    Activity currentActivity = getCurrentActivity();

    <span class="hljs-keyword">if</span> (currentActivity == <span class="hljs-keyword">null</span>) {
      promise.reject(E_ACTIVITY_DOES_NOT_EXIST, <span class="hljs-string">"Activity doesn't exist"</span>);
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">// Store the promise to resolve/reject when picker returns data</span>
    mPickerPromise = promise;

    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">final</span> Intent galleryIntent = <span class="hljs-keyword">new</span> Intent(Intent.ACTION_PICK);

      galleryIntent.setType(<span class="hljs-string">"image/*"</span>);

      <span class="hljs-keyword">final</span> Intent chooserIntent = Intent.createChooser(galleryIntent, <span class="hljs-string">"Pick an image"</span>);

      currentActivity.startActivityForResult(chooserIntent, IMAGE_PICKER_REQUEST);
    } <span class="hljs-keyword">catch</span> (Exception e) {
      mPickerPromise.reject(E_FAILED_TO_SHOW_PICKER, e);
      mPickerPromise = <span class="hljs-keyword">null</span>;
    }
  }
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="监听生命周期事件"></a><a href="#监听生命周期事件" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>监听生命周期事件</h3>
<p>监听 activity 的生命周期事件（比如<code>onResume</code>, <code>onPause</code>等等）和我们在前面实现 <code>ActivityEventListener</code>的做法类似。模块必须实现<code>LifecycleEventListener</code>，然后需要在构造函数中注册一个监听函数：</p>
<pre><code class="hljs css language-java">reactContext.addLifecycleEventListener(<span class="hljs-keyword">this</span>);
</code></pre>
<p>现在你可以通过实现下列方法来监听 activity 的生命周期事件了：</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHostResume</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Activity `onResume`</span>
}

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHostPause</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Activity `onPause`</span>
}

<span class="hljs-meta">@Override</span>
<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onHostDestroy</span><span class="hljs-params">()</span> </span>{
    <span class="hljs-comment">// Activity `onDestroy`</span>
}
</code></pre>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/docs/next/app-extensions"><span class="arrow-prev">← </span><span class="function-name-prevnext">iOS应用扩展</span></a><a class="docs-next button" href="/docs/next/native-components-android"><span>原生UI组件</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#native-module-setup">Native Module Setup</a><ul class="toc-headings"><li><a href="#开启-gradle-daemon">开启 Gradle Daemon</a></li></ul></li><li><a href="#toast-模块">Toast 模块</a><ul class="toc-headings"><li><a href="#参数类型">参数类型</a></li><li><a href="#注册模块">注册模块</a></li></ul></li><li><a href="#更多特性">更多特性</a><ul class="toc-headings"><li><a href="#回调函数">回调函数</a></li><li><a href="#promises">Promises</a></li><li><a href="#多线程">多线程</a></li><li><a href="#发送事件到-javascript">发送事件到 JavaScript</a></li><li><a href="#从startactivityforresult中获取结果">从<code>startActivityForResult</code>中获取结果</a></li><li><a href="#监听生命周期事件">监听生命周期事件</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright"><p style="color:inherit">React Native中文网 © 2020 武汉青罗网络科技有限公司</p><p style="color:inherit"><a href="http://beian.miit.gov.cn/">鄂ICP备20002031号</a><img src="https://img.alicdn.com/tfs/TB1..50QpXXXXX7XpXXXXXXXXXX-40-40.png" alt="鄂公网安备 42011202001821号"/><a href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=42011202001821">鄂公网安备 42011202001821号</a></p></section><script>
        (function(){
          var c = document.createElement("div");
          c.setAttribute("id", "lv-container");
          c.setAttribute("data-id", "city");
          c.setAttribute("data-uid", "MTAyMC8zODM4NS8xNDkxMw==");
          var container = document.querySelector(".mainContainer")
          container && container.appendChild(c);
        })()
        </script><script src="https://cdn-city.livere.com/js/embed.dist.js"></script></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: '7ab53ed26928639bae06ef0f6165f68b',
                indexName: 'reactnative_cn',
                inputSelector: '#search_input_react',
                algoliaOptions: {"hitsPerPage":5}
              });
            </script></body></html>